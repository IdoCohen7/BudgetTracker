# Expense Tracker Project

## ספריות בשימוש

### צד שרת (Backend)

- **EntityFramework Core:** מידול הקשרים בין הישויות באפליקציה וחיבור ל-SQL Server.
- **FluentValidation:** הוספת ולידציות על תהליכי יצירת משתמש ויצירת הוצאות.
- **BCrypt.Net:** הצפנת סיסמאות בבסיס הנתונים לאבטחה מרבית.
- **JwtBearer:** הטמעת מנגנון אבטחה ואימות משתמשים (Authentication).
- **Mapster:** מיפוי יעיל של מודלים פנימיים לאובייקטי נתונים (DTOs).

### צד לקוח (Frontend)

- **React-Bootstrap:** ספריית עיצוב רספונסיבית ששימשה לבניית כל רכיבי הממשק.
- **Axios:** ניהול ושליחת קריאות API לשרת.
- **Recharts:** הצגת נתונים ויזואלית באמצעות גרפים.
- **React-Router-Dom:** ניהול הניווט באפליקציה לחוויית משתמש מהירה וחלקה.

---

## בחירות ארכיטקטוניות

### צד שרת

המערכת מבוססת על שתי ישויות מרכזיות: **משתמש** ו**הוצאה**.

- **קשרי גומלין:** ביססתי קשר של יחיד לרבים (One-to-Many), כך שכל הוצאה משויכת למשתמש אחד, ולכל משתמש יכולות להיות הוצאות רבות.
- **ניהול קטגוריות:** שדה הקטגוריה מומש כ-`Enum` מתוך הבנה שמדובר בטווח ערכים סגור וקבוע מראש.
- **אבטחה והפרדה:** נעשה שימוש ב-DTOs כדי לא לחשוף את מימוש הדאטאבייס הפנימי וכדי לאגד בקשות API בצורה מסודרת.
- **שכבות המערכת:** קיימת הפרדה ברורה בין השכבות:
  - ה-**DbContext** אחראי על החיבור לבסיס הנתונים.
  - ה-**Service** מכיל את הלוגיקה העסקית ומוזרק לשכבות הרלוונטיות.
  - ה-**Controllers** אחראים אך ורק על חשיפת Endpoints והחזרת תגובות HTTP.
- **אימות נתונים:** השתמשתי ב-Validators לאימות פורמט המידע בבקשות POST להרשמה ויצירת הוצאה.

### צד לקוח

- **ניהול מצב (State Management):** בחרתי ב-**Context API** לניהול המידע על ההוצאות שנמשך מהשרת. במידה והיה צורך רחב יותר במידע על המשתמש, הייתי מייצר גם AuthContext ייעודי.
- **מבנה שכבות:** קיימת שכבת API המגדירה את הגדרות ה-Axios, ושכבת Service המממשת את המתודות מול ה-Controllers בשרת.
- **יעילות הקוד:** פונקציות שחוזרות על עצמן הועברו לקובץ **Utils** כדי למנוע שכפול קוד ולשמור על סדר.
